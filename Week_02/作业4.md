学习笔记
串行GC,并行GC,CMS GC,G1 GC共同点：

在内存为256M时候，内存不够使用，不论怎么回收，老年代都会堆满活动对象无法回收，四种GC算法都无法处理这样的场景，最后都会导致OOM，在内存足够用时候，内存8g以上，老年代不会出现内存不够用的情况，四种GC算法都不需要进行full gc, 也不是内存越高越好，和机子的性能也有关系 ，对于同一种GC而言，堆内存空间越大，触发GC的次数就越少，相对地业务线程的执行时间会变多，吞吐量也就会提升

串行GC,并行GC,CMS GC,G1 GC不同点：

在堆内存比较小时候，四种GC的频次都比较高，在这样场景下每次GC中存活的对象都是很少的，多线程并行处理并不能发挥出优势来，反而会有多线程竞争，造成时间浪费，此时串行GC下的吞吐率反而高于并行GC的吞吐率，但是堆内存比较充足的情况下，gc次数减少，每次GC的存活对象相对多一些时候，并行多线程就会发挥出优势，从统计结果中可以看出内存量比较充足时候，并行GC下的吞吐量是最大的，串行GC的吞吐量是最低的，CMS GC 的实现中GC和业务线程是并发执行的，目的是减少延迟，回收效率相比并行GC要低一些，吞吐量相对并行GC而言同样会低一些，同样的，G1 GC并不是每一次GC都把所有垃圾对象清理掉，回收效率相对并行GC而言低一些，总的吞吐率也相对低一些，并且由于是启发式的GC算法，所以造成吞吐率浮动比较大，表现出来的垃圾回收效率没有其他几种GC稳定
